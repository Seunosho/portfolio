import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
  author: 'Adam Wathan',
  date: '2022-05-09',
  title: 'Typescript with React',
  description:
    'TypeScript support in React helps make apps more robust, maintainable and enjoyable to write. Static types are great for documenting and validating complex components, state and data structures. Adopting TypeScript may involve some initial cost, but pays off in the long run for most React codebases.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

TypeScript support in React helps make apps more robust, maintainable and enjoyable to write. Static types are great for documenting and validating complex components, state and data structures. Adopting TypeScript may involve some initial cost, but pays off in the long run for most React codebases.

<b>Typing Props</b>

We can add TypeScript types for component props to validate the data passed in. For example:

```c
interface User {
  name: string;
  id: number;
}

function Profile(props: User) {
  // ..
};
```
Props are validated against the User interface. Destructuring also works:

```c
function Profile({ name, id }: User) {
  // ...
};
```
<b>Typing State</b>

We can also type the state of a component:

```c
interface UserState {
  user: User | null;
}

class Profile extends React.Component<{}, UserState> {
  state: UserState = {
    user: null
  }
};
```

<b>Typing Event Handlers</b>

We can add types for event handlers such as:

```c
interface AppProps {
  message: string;
}

function App({ message }: AppProps) {

  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
    setMessage(e.target.value)
  }

  return (
    <input 
      value={message}
      onChange={handleChange} 
    />
  )
};
```
Typing the event provides autocomplete and validation.

<b>Interface or Type?</b>

interface and type aliases can both be used for type definitions in TypeScript. Here are the key differences:

Interfaces can be extended, types cannot.

Types can do more advanced types like union types.

Use interfaces for dictating structure, types for composable building blocks.


<b>Generics</b>


Types like interfaces can be made generic and reusable:

```c
interface List<T> {
  items: T[];
}

const nums: List<number> = {
  items: [1, 2, 3]
};
```


